use crate::borders::Border;
use crate::Value;
// pub fn parse(key: &str, delim: &str, string: &str) -> std::io::Result<String> {
//     let mut line = string.lines().find(|n| n.contains(key));
//     if line.is_some() {
//         Ok(line
//             .take(
//             .to_string())
//     } else {
//         Err(std::io::Error::new(
//             std::io::ErrorKind::InvalidData,
//             "no key found",
//         ))
//     }
// }
//
// pub fn remove_trailing<'a>(string: &'a str, suffix: &str) -> &'a str {
//     string.strip_suffix(suffix).unwrap_or(string)
// }
//

pub trait Module {
    fn print(config: Option<&Value>, default: &'static str) -> String {
        match &Self::get_val() {
            Some(value) => {
                let a = Self::get_format(config, default)
                    .replace("$value", format!("{}", value).as_str());
                Self::add_border(a, 0, 0) + "".to_string()
            }
            None => String::default(),
        }
    }
    fn get_format(config: Option<&Value>, default: &str) -> String {
        match config {
            Some(con) => match con.get("format") {
                Some(con) => con.as_str().get_or_insert(default).to_string(),
                None => String::from(default),
            },
            None => default.to_string(),
        }
    }
    fn get_val() -> Option<String> {
        None
    }
    fn add_border(data: String, padding: usize, height: usize) -> String {
        if data.is_empty() {
            return data;
        }
        let longest_string = data.lines().map(|x| x.chars().count()).max().unwrap_or(0) + padding;
        let data_formated = format!(
            "{:\n^h$}",
            data,
            h = if height == 0 {
                0
            } else {
                data.chars().count() + height
            }
        )
        .lines()
        .map(|x| {
            format!(
                "{left}{:^width$}{right}\n",
                x,
                width = longest_string,
                left = Border::get(&Border::Left),
                right = Border::get(&Border::Right),
            )
        })
        .collect::<String>();
        format!(
            "{cor0}{top}{cor1}\n{data}{cor2}{bot}{cor3}",
            top = Border::get(&Border::Top).repeat(longest_string),
            data = data_formated,
            bot = Border::get(&Border::Bottom).repeat(longest_string),
            cor0 = Border::get(&Border::TopCornerLeft),
            cor1 = Border::get(&Border::TopCornerRight),
            cor2 = Border::get(&Border::BotCornerLeft),
            cor3 = Border::get(&Border::BotCornerRight)
        )
    }
}
